# TypeScript ì½”ë“œ ê°œì„  ì‚¬í•­

ë¶„ì„ ë‚ ì§œ: 2025-12-21
í”„ë¡œì íŠ¸: shop-nestjs

## ğŸ”´ High Priority - ì¦‰ì‹œ ìˆ˜ì • í•„ìš”

### 1. `any` íƒ€ì… ë‚¨ìš© ì œê±°

#### src/application/common/required_port/http-client.interface.ts:48-49
```typescript
// âŒ í˜„ì¬
params?: Record<string, any>;
data?: any;

// âœ… ê°œì„ ì•ˆ
params?: Record<string, string | number | boolean>;
data?: unknown;  // ë˜ëŠ” ì œë„¤ë¦­ íƒ€ì… ì‚¬ìš©
```

#### src/application/layer-zero/layer-zero.service.ts:35,48
```typescript
// âŒ í˜„ì¬
const response = await this.httpClient.get<Record<string, any>>(url)
const v2Deployment = chainData.deployments?.find((d: any) => d.version === 2)

// âœ… ê°œì„ ì•ˆ
// ì ì ˆí•œ íƒ€ì… ì •ì˜ ì¶”ê°€
type LayerZeroDeployment = {
    version: number;
    eid?: number;
};

type LayerZeroChainDetails = {
    chainType: string;
    nativeChainId?: number;
};

type LayerZeroMetadata = {
    deployments?: LayerZeroDeployment[];
    chainDetails?: LayerZeroChainDetails;
};

const response = await this.httpClient.get<Record<string, LayerZeroMetadata>>(url)
const v2Deployment = chainData.deployments?.find((d) => d.version === 2)
```

#### src/infrastructure/neo4j/neo4j.result.converter.ts:125,135,150
```typescript
// âŒ í˜„ì¬
private validateChainProperties(props: any): asserts props is ChainNodeProperties
private validateTokenProperties(props: any): asserts props is TokenNodeProperties
private validateRelationshipProperties(props: any): asserts props is RelationshipProperties

// âœ… ê°œì„ ì•ˆ
private validateChainProperties(props: unknown): asserts props is ChainNodeProperties
private validateTokenProperties(props: unknown): asserts props is TokenNodeProperties
private validateRelationshipProperties(props: unknown): asserts props is RelationshipProperties
```

#### src/adapter/secondary/http-client/axios-http-client.adapter.ts:74,124,135,148,161,172
```typescript
// âŒ í˜„ì¬
async request<T = any, E = any>(...)
async get<T = any, E = any>(...)
async post<T = any, E = any>(...)
async put<T = any, E = any>(...)
async delete<T = any, E = any>(...)
async patch<T = any, E = any>(...)

// âœ… ê°œì„ ì•ˆ - ê¸°ë³¸ íƒ€ì…ì„ unknownìœ¼ë¡œ
async request<T = unknown, E = unknown>(...)
async get<T = unknown, E = unknown>(...)
async post<T = unknown, E = unknown>(...)
async put<T = unknown, E = unknown>(...)
async delete<T = unknown, E = unknown>(...)
async patch<T = unknown, E = unknown>(...)
```

### 2. íƒ€ì… ì˜¤íƒ€ ìˆ˜ì •

#### src/application/quoter/bridge/stargate/stargate.response.ts:30
```typescript
// âŒ í˜„ì¬
erorr: any,

// âœ… ê°œì„ ì•ˆ
error: string | null,  // ë˜ëŠ” ì ì ˆí•œ ì—ëŸ¬ íƒ€ì… ì •ì˜
```

## ğŸŸ¡ Medium Priority - ì ì§„ì  ê°œì„  ê¶Œì¥

### 3. ê³¼ë„í•œ íƒ€ì… ë‹¨ì–¸ (`as`) ì œê±°

#### src/domain/defi-type.enum.ts:8-14 (getProtocolType)
```typescript
// âŒ í˜„ì¬
export const getProtocolType = (relType: string): ProtocolType => {
    const validValues = Object.values(ProtocolType);
    if (validValues.includes(relType as ProtocolType)) {
        return relType as ProtocolType;
    }
    throw new Error(`Bad ProtocolType string given. given={${relType}}`);
};

// âœ… ê°œì„ ì•ˆ - íƒ€ì… ê°€ë“œ ì‚¬ìš©
function isProtocolType(value: string): value is ProtocolType {
    return Object.values(ProtocolType).includes(value as ProtocolType);
}

export const getProtocolType = (relType: string): ProtocolType => {
    if (isProtocolType(relType)) {
        return relType;  // íƒ€ì… ë‹¨ì–¸ ë¶ˆí•„ìš”
    }
    throw new Error(`Bad ProtocolType string given. given={${relType}}`);
};
```

#### src/domain/defi-type.enum.ts:22-28 (swapProtocolFromString)
```typescript
// âŒ í˜„ì¬
export const swapProtocolFromString = (swapProtocol: string): SwapProtocol => {
    const validValues = Object.values(SwapProtocol);
    if (validValues.includes(swapProtocol as SwapProtocol)) {
        return swapProtocol as SwapProtocol;
    }
    throw new Error(`Bad SwapProtocol string given. given={${swapProtocol}}`);
}

// âœ… ê°œì„ ì•ˆ
function isSwapProtocol(value: string): value is SwapProtocol {
    return Object.values(SwapProtocol).includes(value as SwapProtocol);
}

export const swapProtocolFromString = (swapProtocol: string): SwapProtocol => {
    if (isSwapProtocol(swapProtocol)) {
        return swapProtocol;
    }
    throw new Error(`Bad SwapProtocol string given. given={${swapProtocol}}`);
}
```

#### src/domain/defi-type.enum.ts:35-41 (bridgeProtocolFromString)
```typescript
// âŒ í˜„ì¬
export const bridgeProtocolFromString = (bridgeProtocol: string): BridgeProtocol => {
    const validValues = Object.values(BridgeProtocol);
    if (validValues.includes(bridgeProtocol as BridgeProtocol)) {
        return bridgeProtocol as BridgeProtocol;
    }
    throw new Error(`Bad BridgeProtocol string given. given={${bridgeProtocol}}`);
}

// âœ… ê°œì„ ì•ˆ
function isBridgeProtocol(value: string): value is BridgeProtocol {
    return Object.values(BridgeProtocol).includes(value as BridgeProtocol);
}

export const bridgeProtocolFromString = (bridgeProtocol: string): BridgeProtocol => {
    if (isBridgeProtocol(bridgeProtocol)) {
        return bridgeProtocol;
    }
    throw new Error(`Bad BridgeProtocol string given. given={${bridgeProtocol}}`);
}
```

#### src/domain/defi-type.enum.ts:93-109 (ProtocolInfo ìƒìˆ˜ë“¤)
```typescript
// âŒ í˜„ì¬ - ë¶ˆí•„ìš”í•œ íƒ€ì… ë‹¨ì–¸
const oneInchClassicSwapProtocolInfo = {
    protocolName: SwapProtocol.ONE_INCH,
    protocolType: ProtocolType.SWAP,
    version: "V1",
} as ProtocolInfo

const sushiSwapSimpleProtocolInfo = {
    protocolName: SwapProtocol.SUSHI_SWAP,
    protocolType: ProtocolType.SWAP,
    version: "V1",
} as ProtocolInfo

const stargateBridgeProtocolInfo = {
    protocolName: BridgeProtocol.STARGATE,
    protocolType: ProtocolType.BRIDGE,
    version: "V2",
} as ProtocolInfo

// âœ… ê°œì„ ì•ˆ - íƒ€ì… ë‹¨ì–¸ ì—†ì´ ì •í™•í•œ íƒ€ì… ì‚¬ìš©
const oneInchClassicSwapProtocolInfo: ProtocolInfo = {
    protocolName: SwapProtocol.ONE_INCH,
    protocolType: ProtocolType.SWAP,
    version: "V1",
}

const sushiSwapSimpleProtocolInfo: ProtocolInfo = {
    protocolName: SwapProtocol.SUSHI_SWAP,
    protocolType: ProtocolType.SWAP,
    version: "V1",
}

const stargateBridgeProtocolInfo: ProtocolInfo = {
    protocolName: BridgeProtocol.STARGATE,
    protocolType: ProtocolType.BRIDGE,
    version: "V2",
}
```

#### src/infrastructure/neo4j/neo4j.result.converter.ts:20-21
```typescript
// âŒ í˜„ì¬
const path = record.get(pathVairalbeName) as Path;
const chains = record.get('chains') as Node[];

// âœ… ê°œì„ ì•ˆ - ëŸ°íƒ€ì„ ê²€ì¦ ì¶”ê°€
const pathValue = record.get(pathVairalbeName);
if (!this.isPath(pathValue)) {
    throw new Error('Invalid path structure');
}
const path = pathValue;

const chainsValue = record.get('chains');
if (!Array.isArray(chainsValue) || !chainsValue.every(this.isNode)) {
    throw new Error('Invalid chains structure');
}
const chains = chainsValue;

// í—¬í¼ ë©”ì„œë“œ ì¶”ê°€
private isPath(value: unknown): value is Path {
    return value !== null &&
           typeof value === 'object' &&
           'segments' in value &&
           Array.isArray((value as any).segments);
}

private isNode(value: unknown): value is Node {
    return value !== null &&
           typeof value === 'object' &&
           'properties' in value;
}
```

#### src/infrastructure/neo4j/neo4j.result.converter.ts:70,84,105
```typescript
// âŒ í˜„ì¬
const chainProps = chainNode.properties as ChainNodeProperties;
const tokenProps = tokenNode.properties as TokenNodeProperties;
const relProps = relationship.properties as RelationshipProperties;

// âœ… ê°œì„ ì•ˆ - validate í›„ íƒ€ì… ë‹¨ì–¸ ì œê±°
const chainProps = chainNode.properties;
this.validateChainProperties(chainProps);
// ì´í›„ chainPropsëŠ” ChainNodeProperties íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ë¨

const tokenProps = tokenNode.properties;
this.validateTokenProperties(tokenProps);

const relProps = relationship.properties;
this.validateRelationshipProperties(relProps);
```

#### src/domain/defi-type.enum.ts:74,83
```typescript
// âŒ í˜„ì¬
if (!validSwapProtocols.includes(info.protocolName as SwapProtocol)) {
if (!validBridgeProtocols.includes(info.protocolName as BridgeProtocol)) {

// âœ… ê°œì„ ì•ˆ - discriminated union í™œìš©
export const validateProtocolInfo = (info: ProtocolInfo): void => {
    if (info.protocolType === ProtocolType.SWAP) {
        const validSwapProtocols = Object.values(SwapProtocol);
        // info.protocolNameì€ ì´ë¯¸ SwapProtocol íƒ€ì…ìœ¼ë¡œ ì¢í˜€ì§
        if (!validSwapProtocols.includes(info.protocolName)) {
            throw new Error(
                `ProtocolInfo validation failed: protocolType is SWAP but protocolName "${info.protocolName}" is not a valid SwapProtocol. ` +
                `Valid values: ${validSwapProtocols.join(', ')}`
            );
        }
    } else if (info.protocolType === ProtocolType.BRIDGE) {
        const validBridgeProtocols = Object.values(BridgeProtocol);
        // info.protocolNameì€ ì´ë¯¸ BridgeProtocol íƒ€ì…ìœ¼ë¡œ ì¢í˜€ì§
        if (!validBridgeProtocols.includes(info.protocolName)) {
            throw new Error(
                `ProtocolInfo validation failed: protocolType is BRIDGE but protocolName "${info.protocolName}" is not a valid BridgeProtocol. ` +
                `Valid values: ${validBridgeProtocols.join(', ')}`
            );
        }
    }
};
```

### 4. íƒ€ì… ê°€ë“œ ê°œì„ 

#### src/domain/defi-type.enum.ts:56-62
```typescript
// âš ï¸ í˜„ì¬ - ë°˜í™˜ íƒ€ì…ì´ ì •í™•í•˜ì§€ ì•ŠìŒ
export const isSwapProtocol = (info: ProtocolInfo): info is ProtocolInfo & { type: ProtocolType.SWAP } => {
    return info.protocolType === ProtocolType.SWAP;
};

export const isBridgeProtocol = (info: ProtocolInfo): info is ProtocolInfo & { type: ProtocolType.BRIDGE } => {
    return info.protocolType === ProtocolType.BRIDGE;
};

// âœ… ê°œì„ ì•ˆ - Extract ìœ í‹¸ë¦¬í‹° íƒ€ì… ì‚¬ìš©
export const isSwapProtocol = (
    info: ProtocolInfo
): info is Extract<ProtocolInfo, { protocolType: ProtocolType.SWAP }> => {
    return info.protocolType === ProtocolType.SWAP;
};

export const isBridgeProtocol = (
    info: ProtocolInfo
): info is Extract<ProtocolInfo, { protocolType: ProtocolType.BRIDGE }> => {
    return info.protocolType === ProtocolType.BRIDGE;
};
```

## ğŸŸ¢ Low Priority - ì„ íƒì  ê°œì„ 

### 5. íƒ€ì… ë‹¨ì–¸ ëŒ€ì‹  íƒ€ì… í—¬í¼ í™œìš©

#### src/utils/time/duration.ms.ts:4-13
```typescript
// âŒ í˜„ì¬
export const DurationMs = {
  seconds: (n: number) => n * 1000 as DurationMs,
  minutes: (n: number) => n * 60 * 1000 as DurationMs,
  // ...
  ONE_MINUTE: 60 * 1000 as DurationMs,
  ONE_HOUR: 60 * 60 * 1000 as DurationMs,
} as const;

// âœ… ê°œì„ ì•ˆ - íƒ€ì… í—¬í¼ í•¨ìˆ˜
const createDurationMs = (ms: number): DurationMs => ms as DurationMs;

export const DurationMs = {
  seconds: (n: number) => createDurationMs(n * 1000),
  minutes: (n: number) => createDurationMs(n * 60 * 1000),
  hours: (n: number) => createDurationMs(n * 60 * 60 * 1000),
  days: (n: number) => createDurationMs(n * 24 * 60 * 60 * 1000),

  ONE_MINUTE: createDurationMs(60 * 1000),
  FIVE_MINUTES: createDurationMs(5 * 60 * 1000),
  ONE_HOUR: createDurationMs(60 * 60 * 1000),
  ONE_DAY: createDurationMs(24 * 60 * 60 * 1000),
} as const;
```

#### src/domain/evm-address.class.ts:17
```typescript
// âŒ í˜„ì¬
return this.hash as Hash

// âœ… ê°œì„ ì•ˆ - íƒ€ì… ì •ì˜ë¥¼ ëª…í™•íˆ
// Hash íƒ€ì…ê³¼ ë‚´ë¶€ hash í•„ë“œì˜ íƒ€ì…ì´ ë™ì¼í•˜ë‹¤ë©´ ë‹¨ì–¸ ë¶ˆí•„ìš”
// ì•„ë‹ˆë©´ ìƒì„±ìì—ì„œ íƒ€ì… ê²€ì¦ ì¶”ê°€
```

## ğŸ“Š ê°œì„  ìš°ì„ ìˆœìœ„ ìš”ì•½

### 1ë‹¨ê³„ (ì¦‰ì‹œ): High Priority í•­ëª©
- HTTP í´ë¼ì´ì–¸íŠ¸ ì¸í„°í˜ì´ìŠ¤ `any` â†’ `unknown` ë³€ê²½
- `stargate.response.ts`ì˜ `erorr` ì˜¤íƒ€ ìˆ˜ì •
- Validation í•¨ìˆ˜ë“¤ `any` â†’ `unknown` ë³€ê²½
- LayerZero ì„œë¹„ìŠ¤ íƒ€ì… ì •ì˜ ì¶”ê°€

### 2ë‹¨ê³„ (1-2ì£¼ ë‚´): Medium Priority í•­ëª©
- Enum ë³€í™˜ í•¨ìˆ˜ë“¤ì— íƒ€ì… ê°€ë“œ ì ìš©
- ProtocolInfo ìƒìˆ˜ íƒ€ì… ë‹¨ì–¸ ì œê±°
- Neo4j ê²°ê³¼ ë³€í™˜ê¸° íƒ€ì… ë‹¨ì–¸ ìµœì†Œí™”
- validateProtocolInfo discriminated union í™œìš©

### 3ë‹¨ê³„ (ì ì§„ì ): Low Priority í•­ëª©
- DurationMs í—¬í¼ í•¨ìˆ˜í™”
- ê¸°íƒ€ íƒ€ì… ë‹¨ì–¸ ì •ë¦¬

## ğŸ“ˆ ì˜ˆìƒ íš¨ê³¼

1. **íƒ€ì… ì•ˆì „ì„± í–¥ìƒ**: `any` ì œê±°ë¡œ ì»´íŒŒì¼ íƒ€ì„ ì—ëŸ¬ ê°ì§€ ì¦ê°€
2. **ì½”ë“œ ê°€ë…ì„± ê°œì„ **: íƒ€ì… ë‹¨ì–¸ ê°ì†Œë¡œ ì˜ë„ê°€ ëª…í™•í•´ì§
3. **ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ**: íƒ€ì… ê°€ë“œë¡œ ëŸ°íƒ€ì„ ê²€ì¦ ê°•í™”
4. **ë¦¬íŒ©í† ë§ ì•ˆì „ì„±**: íƒ€ì… ì‹œìŠ¤í…œì´ ë³€ê²½ì‚¬í•­ ì¶”ì 

## ğŸ”§ ì ìš© ë°©ë²•

ê° íŒŒì¼ë³„ë¡œ ì ì§„ì ìœ¼ë¡œ ì ìš©í•˜ë˜, ë³€ê²½ í›„ ë°˜ë“œì‹œ:
1. íƒ€ì… ì²´í¬: `npm run build` ë˜ëŠ” `tsc --noEmit`
2. í…ŒìŠ¤íŠ¸ ì‹¤í–‰: `npm test`
3. ë¦°íŠ¸ ì²´í¬: `npm run lint`

## ì°¸ê³  ì‚¬í•­

- tsconfig.jsonì˜ strict ì„¤ì •ì€ ì˜ ë˜ì–´ ìˆìŒ (noImplicitAny, strictNullChecks ë“±)
- `@ts-ignore`, `@ts-nocheck` ì‚¬ìš© ì—†ìŒ (ì¢‹ìŒ)
- ì „ë°˜ì ìœ¼ë¡œ íƒ€ì… ì‹œìŠ¤í…œì„ í™œìš©í•˜ë ¤ëŠ” ì˜ì§€ê°€ ë³´ì„
- ì£¼ë¡œ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ íƒ€ì…ê³¼ì˜ ìƒí˜¸ì‘ìš©ì—ì„œ íƒ€ì… ë‹¨ì–¸ì´ ë§ì´ ì‚¬ìš©ë¨

========================================================================

// Line 74-85
  async request<T = unknown, E = unknown>(...): Promise<HttpResponse<T, E>> {
      const response = await this.axiosInstance.request<T>(axiosConfig);

      return {
          data: response.data,  // âš ï¸ response.dataëŠ” ì‹¤ì œë¡œ ë­ë“  ë  ìˆ˜ ìˆìŒ
          // ...
      };
  }

  ë¬¸ì œ: TypeScript ì œë„¤ë¦­ì€ ì»´íŒŒì¼ íƒ€ì„ì—ë§Œ ì¡´ì¬

  // ì‚¬ìš© ì˜ˆì‹œ
  interface User { id: number; name: string; }

  const result = await httpClient.get<User>('/api/user/1');
  // âœ… TypeScriptëŠ” result.dataê°€ User íƒ€ì…ì´ë¼ê³  "ë¯¿ìŒ"

  // í•˜ì§€ë§Œ ì‹¤ì œ APIê°€ ì´ë ‡ê²Œ ë°˜í™˜í•˜ë©´?
  // { error: "User not found", code: 404 }

  console.log(result.data.name); // ğŸ’¥ ëŸ°íƒ€ì„ ì—ëŸ¬! (undefined.name)

  TypeScriptëŠ” ëŸ°íƒ€ì„ì— íƒ€ì… ì²´í¬ë¥¼ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (Type Erasure)

  ---
  í•´ê²° ë°©ì•ˆ 3ê°€ì§€

  1ï¸âƒ£ í˜„ì¬ ë°©ì‹ ìœ ì§€ (íƒ€ì… ì²´í¬ ì•ˆ í•¨)

  ì–¸ì œ ê´œì°®ì€ê°€?
  - âœ… ë‚´ë¶€ API (ê°™ì€ íŒ€/ì¡°ì§)
  - âœ… API ìŠ¤í™ì´ ì•ˆì •ì 
  - âœ… ë¹ ë¥¸ ê°œë°œ ìš°ì„ 
  - âœ… Backendì™€ ê³„ì•½ëœ íƒ€ì… ë³´ì¥

  ë‹¨ì :
  - âŒ API ìŠ¤í™ ë³€ê²½ ì‹œ ëŸ°íƒ€ì„ ì—ëŸ¬
  - âŒ ì™¸ë¶€ API ì‚¬ìš© ì‹œ ìœ„í—˜

  ---
  2ï¸âƒ£ Runtime Validation ì¶”ê°€ (ê¶Œì¥)

  Option A: Zodë¥¼ ì‚¬ìš©í•œ ëŸ°íƒ€ì„ ê²€ì¦

  import { z } from 'zod';

  // request ë©”ì†Œë“œì— validation ì¶”ê°€
  async request<T = unknown, E = unknown>(
      config: HttpRequestConfig,
      options?: {
          responseSchema?: z.ZodType<T>;  // ì„ íƒì  ê²€ì¦
          errorSchema?: z.ZodType<E>;
      }
  ): Promise<HttpResponse<T, E>> {
      const response = await this.axiosInstance.request<T>(axiosConfig);

      // ëŸ°íƒ€ì„ ê²€ì¦ (ì˜µì…˜)
      if (options?.responseSchema) {
          const validated = options.responseSchema.parse(response.data);
          return {
              data: validated,  // âœ… ê²€ì¦ëœ ë°ì´í„°
              // ...
          };
      }

      return {
          data: response.data,  // ê²€ì¦ ì—†ìŒ (ê¸°ì¡´ ë™ì‘)
          // ...
      };
  }

  // ì‚¬ìš© ì˜ˆì‹œ
  const UserSchema = z.object({
      id: z.number(),
      name: z.string(),
  });

  const result = await httpClient.get<z.infer<typeof UserSchema>>('/api/user/1', {
      responseSchema: UserSchema,  // âœ… ëŸ°íƒ€ì„ ê²€ì¦!
  });

  Option B: class-validator + class-transformer

  import { plainToInstance } from 'class-transformer';
  import { validate } from 'class-validator';

  async request<T = unknown, E = unknown>(
      config: HttpRequestConfig,
      options?: {
          responseDto?: new () => T;  // DTO í´ë˜ìŠ¤
      }
  ): Promise<HttpResponse<T, E>> {
      const response = await this.axiosInstance.request(axiosConfig);

      if (options?.responseDto) {
          const instance = plainToInstance(options.responseDto, response.data);
          const errors = await validate(instance);

          if (errors.length > 0) {
              throw new Error(`Validation failed: ${JSON.stringify(errors)}`);
          }

          return {
              data: instance as T,  // âœ… ê²€ì¦ëœ DTO
              // ...
          };
      }

      return { data: response.data, ... };
  }

  ---
  3ï¸âƒ£ DTO Layerì—ì„œ ê²€ì¦ (ê°€ì¥ ì‹¤ìš©ì )

  HTTP ClientëŠ” ê·¸ëŒ€ë¡œ ë‘ê³ , Service/UseCase ë ˆì´ì–´ì—ì„œ ê²€ì¦:

  // user.service.ts
  export class UserService {
      constructor(private readonly httpClient: IHttpClient) {}

      async getUser(id: number): Promise<User> {
          const response = await this.httpClient.get<unknown>('/api/user/' + id);

          // âœ… ì—¬ê¸°ì„œ ê²€ì¦
          const validated = UserSchema.parse(response.data);
          return validated;
      }
  }

  ì¥ì :
  - âœ… HTTP ClientëŠ” ë‹¨ìˆœí•˜ê²Œ ìœ ì§€
  - âœ… ë„ë©”ì¸ ë¡œì§ê³¼ ê²€ì¦ ë¶„ë¦¬
  - âœ… ê° UseCaseë§ˆë‹¤ í•„ìš”í•œ ê²€ì¦ë§Œ ìˆ˜í–‰

  ---
  ê²°ë¡  ë° ê¶Œì¥ì‚¬í•­

  í˜„ì¬ í”„ë¡œì íŠ¸ ìƒí™©ì— ë”°ë¼ ì„ íƒ:

  | ìƒí™©                  | ê¶Œì¥ ë°©ì•ˆ                        |
  |-----------------------|----------------------------------|
  | ë‚´ë¶€ API, ì•ˆì •ì  ìŠ¤í™ | í˜„ì¬ ë°©ì‹ ìœ ì§€ (íƒ€ì… ì²´í¬ ì•ˆ í•¨) |
  | ì™¸ë¶€ API, ìŠ¤í™ ë³€ë™   | DTO Layer ê²€ì¦ (ë°©ì•ˆ 3)          |
  | Critical ì„œë¹„ìŠ¤       | Runtime Validation ì¶”ê°€ (ë°©ì•ˆ 2) |

  ì œ ì¶”ì²œ:

  // 1. HTTP ClientëŠ” í˜„ì¬ì²˜ëŸ¼ ìœ ì§€ (ì‹¬í”Œí•˜ê²Œ)
  // 2. Service/UseCase ë ˆì´ì–´ì—ì„œ Zodë¡œ ê²€ì¦

  // user.service.ts
  const UserSchema = z.object({
      id: z.number(),
      name: z.string(),
      email: z.string().email(),
  });

  async getUser(id: number): Promise<User> {
      const response = await this.httpClient.get<unknown>(`/users/${id}`);
      return UserSchema.parse(response.data);  // âœ… ì•ˆì „!
  }
